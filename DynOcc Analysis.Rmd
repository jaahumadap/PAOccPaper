---
title: "Simulation analysis - dynamic models"
author: "Jorge A. Ahumada"
date: "March 22, 2016"
output: html_document
---

```{r setup, include=FALSE}
library(unmarked)
library(ggplot2)
gm_mean = function(x, na.rm=TRUE, zero.propagate = FALSE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(zero.propagate){
    if(any(x == 0, na.rm = TRUE)){
      return(0)
    }
    exp(mean(log(x), na.rm = na.rm))
  } else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
  }
}
```

### Function to simulate the data
Using this function to simulate a dynamic occupancy model with *n* points, *t* years (primary periods), *d* days (secondary periods), initial occupancy $\psi$, survival probability $\phi$, colonization probability $\gamma$ and detection probabilty *p*:
```{r cars}
data.generator<-function(points,days,psi,p,phi,gamma,years) {
        require(unmarked)
        #first year of data
        y1<-matrix(NA,nr=points,nc=days)
        #generate the expected occupancies
        z<-rbinom(points,1,psi)
        #generate the observations
        for(i in 1:points)
                y1[i,]<-rbinom(days,1,z[i]*p)
        #subsequent years
        #three dimensional matrix to store the results
        yk<-array(NA,dim=c(points,days,years))
        yk[,,1]<-y1
        for(k in 2:years){
        #generate the deterministic part of the model
                occ<-apply(yk[,,k-1],1,max,na.rm=T)
                z<-rbinom(points,1,occ*phi+(1-occ)*gamma)
        #generate the observations
        for(i in 1:points)
                yk[i,,k]<-rbinom(days,1,z[i]*p)
     
        }  
        # convert results to a two dimensional matrix for colext
        yk <- matrix(yk, points, days*years)
        #ny <- matrix(as.character(1:years),nrow(yk), years, byrow=TRUE)
        # store data in an unmarkedMultFrame object so it is ready for analysis
        yUMF <- unmarkedMultFrame(y = yk, numPrimary = years)
        yUMF
 } 
```
Simulate some data:
```{r}
set.seed(400)
data <- data.generator(points = 30,days = 30, psi = 0.5, p = 0.5, phi = 0.2, 
                       gamma = 0, years = 5)

#Look at the first year of data
summary(data)
```
Now, fit a dynamic occupancy model using colext
```{r}
model <- colext(psiformula = ~1,gammaformula = ~1,epsilonformula = ~1, 
                pformula = ~1, data = data, method = "BFGS",se = FALSE)
summary(model)
backTransform(model,type=c("psi"))
backTransform(model,type=c("col"))
backTransform(model,type=c("ext"))
backTransform(model,type=c("det"))
```
Now compare the naive occupancy from the simulation to the fitted occupancy:
```{r}
data3d <- array(data@y,dim = c(30,30,5))
obs <- apply( apply(data3d, c(1,3), max, na.rm = T), 2, sum) / nrow(data3d)
# Estimate the projected trajectory - prediction of occupancy based on an infinite sample of sites
mod <- as.numeric(projected(model)[2,])
# Estimate the smoothed trajectory - prediction of occupancy based on the actual sampled sites
mods <- as.numeric(smoothed(model)[2,])

plot(1:5, obs, type="p",ylim=c(0,1)); lines(1:5, mod); lines(1:5, mods, lty=2)
#abs(mod-obs); abs(mods-obs)
```
Here is a function that repats this process for an arbitrary number of simulations *nsim* and also fits a logistic regression for each simulation, returning both the time series and the parameters of the logistic regression:

```{r}
simulatetrend <- function(points = 10,days = 30, psi = 0.5, p = 0.2, phi = 0.2, gamma = 0, years = 5, nsim = 5) {
        #store results
        results <- matrix(NA, nr = nsim, nc = years)
        gm_lambda <- numeric()
        time <- 1:years
        
        for (i in 1:nsim) {
                #generate data and store projected results
                data <- data.generator(points,days,psi,p,phi,gamma,years)
                model <- colext(~1, ~1, ~1, ~1, data = data, method = "BFGS",se = FALSE)
                results[i,] <- as.numeric(smoothed(model)[2,])
                
                #Calculate geometric mean of lambda
                lambda <- results[i,2:years]/results[i,1:(years-1)]
                gm_lambda[i] <- -(gm_mean(lambda) - 1)
                }
        list(gmlambda = gm_lambda,results = results)
}
```
Running *simulatetrend* with 100 simulations and a 5% decrease in occupancy:
```{r, cache = TRUE}
test <- simulatetrend(points = 100, psi = 0.9, gamma = 0, phi = 0.8, nsim = 100)
```
and then graphing the results:
```{r,echo=FALSE}
res <- data.frame(test$results, id = 1:100)
names(res) <- c(1:(ncol(res)-1),"id")
res <- melt(res,"id")
names(res)[2] <- "year"
ggplot(res, aes(x=year,y=value, group=id))+geom_line(alpha=0.2)
```
examine the distribution of the slope:
```{r, echo = FALSE, message=FALSE}
slopes <- as.data.frame(test$gmlambda)
names(slopes) <- c("slope")
ggplot(slopes,aes(x=slope)) + geom_histogram() + geom_density()

```